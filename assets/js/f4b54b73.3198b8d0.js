"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[1256],{38570:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>m});var i=n(70079);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,i,o=function(e,t){if(null==e)return{};var n,i,o={},l=Object.keys(e);for(i=0;i<l.length;i++)n=l[i],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(i=0;i<l.length;i++)n=l[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var d=i.createContext({}),u=function(e){var t=i.useContext(d),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},p=function(e){var t=u(e.components);return i.createElement(d.Provider,{value:t},e.children)},s="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},h=i.forwardRef((function(e,t){var n=e.components,o=e.mdxType,l=e.originalType,d=e.parentName,p=r(e,["components","mdxType","originalType","parentName"]),s=u(n),h=o,m=s["".concat(d,".").concat(h)]||s[h]||c[h]||l;return n?i.createElement(m,a(a({ref:t},p),{},{components:n})):i.createElement(m,a({ref:t},p))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var l=n.length,a=new Array(l);a[0]=h;var r={};for(var d in t)hasOwnProperty.call(t,d)&&(r[d]=t[d]);r.originalType=e,r[s]="string"==typeof e?e:o,a[1]=r;for(var u=2;u<l;u++)a[u]=n[u];return i.createElement.apply(null,a)}return i.createElement.apply(null,n)}h.displayName="MDXCreateElement"},72690:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>a,default:()=>c,frontMatter:()=>l,metadata:()=>r,toc:()=>u});var i=n(10328),o=(n(70079),n(38570));const l={},a="Advanced Concepts",r={unversionedId:"advanced-concepts",id:"advanced-concepts",title:"Advanced Concepts",description:"Flyde was built with flexibility and power in mind. To enable that, Flyde tries to be reactive and declarative.",source:"@site/docs/7-advanced-concepts.md",sourceDirName:".",slug:"/advanced-concepts",permalink:"/docs/advanced-concepts",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/7-advanced-concepts.md",tags:[],version:"current",sidebarPosition:7,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Testing, Deploying & Versioning",permalink:"/docs/testing-deploying"},next:{title:"Third-Party Nodes",permalink:"/docs/third-party-nodes"}},d={},u=[{value:"Node Instance Input Modes",id:"node-instance-input-modes",level:2},{value:"&quot;Queued&quot;",id:"queued",level:3},{value:"&quot;Sticky&quot;",id:"sticky",level:3},{value:"Node Lifecycle",id:"node-lifecycle",level:2},{value:"&quot;Idle&quot;",id:"idle",level:3},{value:"&quot;Running&quot;",id:"running",level:3},{value:"&#39;Completed&#39; and &#39;Error&#39;",id:"completed-and-error",level:3},{value:"Node Completion",id:"node-completion",level:2},{value:"Implicit Completion",id:"implicit-completion",level:3},{value:"Explicit Completion",id:"explicit-completion",level:3},{value:"Reactive Inputs",id:"reactive-inputs",level:2},{value:"&quot;Manually&quot; Triggering a Node",id:"manually-triggering-a-node",level:2},{value:"Error Handling",id:"error-handling",level:2}],p={toc:u},s="wrapper";function c(e){let{components:t,...n}=e;return(0,o.kt)(s,(0,i.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"advanced-concepts"},"Advanced Concepts"),(0,o.kt)("p",null,"Flyde was built with flexibility and power in mind. To enable that, Flyde tries to be reactive and declarative.\nThis enables building custom flows and custom nodes with little overhead and boilerplate."),(0,o.kt)("h2",{id:"node-instance-input-modes"},"Node Instance Input Modes"),(0,o.kt)("p",null,"Each input of each instance of a node in a flow can be in one of the following modes:"),(0,o.kt)("h3",{id:"queued"},'"Queued"'),(0,o.kt)("p",null,"New values received by the input will be queued, and each time the node runs, it will consume the next value from the queue."),(0,o.kt)("p",null,'Queued inputs are great if you need to "buffer" values, or if you want to make sure that no values are lost.'),(0,o.kt)("h3",{id:"sticky"},'"Sticky"'),(0,o.kt)("p",null,"The input will keep its last value throughout it's parent node/flow's lifecycle. Each new value received by the input will replace the previous value."),(0,o.kt)("p",null,'Sticky inputs are great for values that will act as "dynamic configuration" for the node.'),(0,o.kt)("h2",{id:"node-lifecycle"},"Node Lifecycle"),(0,o.kt)("p",null,"A Node in Flyde can be in one of the following states:"),(0,o.kt)("h3",{id:"idle"},'"Idle"'),(0,o.kt)("p",null,"The node is not performing any work. It stays idle until all its required inputs are satisfied."),(0,o.kt)("h3",{id:"running"},'"Running"'),(0,o.kt)("p",null,'When a node starts running, it\'ll "consume" the values from its inputs and perform its work. This means that any queued inputs will be consumed, and any sticky inputs will be read.'),(0,o.kt)("p",null,'While a node is running, new values will only take effect on the next time it runs, unless they are set as a "reactive input". More on that below.'),(0,o.kt)("p",null,"A node can have implicit or explicit completion triggers. More on that below."),(0,o.kt)("h3",{id:"completed-and-error"},"'Completed' and 'Error'"),(0,o.kt)("p",null,'While not real "states", a node can be in a "completed" state or an "error" state. A node is considered "completed" when it has finished running and has no more work to do. A node is considered in an "error" state when it has thrown an error during its run. Both completed and error states are transient, and a node will go back to the "idle" state after it has completed or errored.'),(0,o.kt)("h2",{id:"node-completion"},"Node Completion"),(0,o.kt)("h3",{id:"implicit-completion"},"Implicit Completion"),(0,o.kt)("p",null,"A node will implicitly complete when it has no more work to do. For code nodes, it means that their ",(0,o.kt)("inlineCode",{parentName:"p"},"run")," method has returned. In case the ",(0,o.kt)("inlineCode",{parentName:"p"},"run")," method returns a promise, the node will implicitly complete when the promise resolves."),(0,o.kt)("p",null,"For visual nodes, it means that all of its children have completed."),(0,o.kt)("p",null,"Implicit completion is the default behavior for nodes."),(0,o.kt)("h3",{id:"explicit-completion"},"Explicit Completion"),(0,o.kt)("p",null,'A node can declare it has explicit completion by declaring a "completionOutputs" property. This property is an array of output names that will trigger the node to complete when they emit a value. It also supports a ',(0,o.kt)("inlineCode",{parentName:"p"},"+")," operator to declare that all outputs should trigger completion."),(0,o.kt)("p",null,"For example:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"completionOutputs: ['output1', 'output2']")," will trigger the node to complete when either ",(0,o.kt)("inlineCode",{parentName:"li"},"output1")," or ",(0,o.kt)("inlineCode",{parentName:"li"},"output2")," emit a value."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"completionOutputs: ['n1+n2']")," will trigger the node to complete when both ",(0,o.kt)("inlineCode",{parentName:"li"},"n1")," AND ",(0,o.kt)("inlineCode",{parentName:"li"},"n2")," emitted a value."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"completionOutputs: ['n1+n2', 'n3']")," will trigger the node to complete when both ",(0,o.kt)("inlineCode",{parentName:"li"},"n1")," AND ",(0,o.kt)("inlineCode",{parentName:"li"},"n2"),", OR just 'm3' emitted a value.")),(0,o.kt)("p",null,'Visual nodes\' completion outputs can be declared explicitly as well by right-clicking the node and selecting "Set Completion Outputs".'),(0,o.kt)("h2",{id:"reactive-inputs"},"Reactive Inputs"),(0,o.kt)("p",null,'A node can declare that an input is "reactive". This means that the node will re-run when the input emits a new value, even if the node is already running.'),(0,o.kt)("p",null,'A great example of when this is useful is a "debounce" node. Imagine a "debounce" node with 2 inputs: ',(0,o.kt)("inlineCode",{parentName:"p"},"value")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"delay"),'. Once a value is received, the node needs to remain in "running" state for the duration of the delay, and then emit the value. But if a node only accepts new values when it is idle, it will not be able to accept the new value of ',(0,o.kt)("inlineCode",{parentName:"p"},"value")," until it has completed."),(0,o.kt)("p",null,"To solve this, we can mark the ",(0,o.kt)("inlineCode",{parentName:"p"},"value"),' input as "reactive", and the node will re-run when the ',(0,o.kt)("inlineCode",{parentName:"p"},"value")," input emits a new value. Updating the ",(0,o.kt)("inlineCode",{parentName:"p"},"delay"),' input will not trigger a re-run, as it is not marked as "reactive", and will only take effect on the next time the node runs.'),(0,o.kt)("h2",{id:"manually-triggering-a-node"},'"Manually" Triggering a Node'),(0,o.kt)("p",null,'By default, a node will run when all of its inputs are satisfied. But sometimes you might want to control when a node runs more granularly. To do so, you may expose a "Trigger" input, which will act as a manual trigger for the node. If this input is connected, the node will only run when it receives a value on the "Trigger" input (and all other inputs are satisfied).'),(0,o.kt)("p",null,'To expose the "trigger" input, right-click the node instance and select the "Show Trigger" option.'),(0,o.kt)("p",null,(0,o.kt)("em",{parentName:"p"},"[ TODO: Add a gif showing how to expose the trigger input]")),(0,o.kt)("h2",{id:"error-handling"},"Error Handling"),(0,o.kt)("p",null,'When a node throws an error, it will be in an "error" state. The error will be displayed in the node\'s UI, and the error will be propagated to the parent node/flow.'),(0,o.kt)("p",null,'To "catch" an error and avoid it from propagating, you can expose the "Error" special output.\nTo expose the "Error" output, right-click the node instance and select the "Show output Error" option.'),(0,o.kt)("p",null,(0,o.kt)("em",{parentName:"p"},"[ TODO: Add a gif showing how to expose the trigger input]")))}c.isMDXComponent=!0}}]);