{
    "Accumulate": {
        "id": "Accumulate",
        "inputs": {
            "count": {
                "mode": "required",
                "type": "any"
            },
            "val": {
                "mode": "optional",
                "type": "any"
            }
        },
        "outputs": {
            "r": {
                "type": "any"
            }
        },
        "completionOutputs": [
            "r"
        ],
        "reactiveInputs": [
            "val"
        ],
        "fnCode": "const {count, val} = inputs;\nconst {r} = outputs;\n\nconst {state} = adv;\n\nlet list = state.get(\"list\") || [];\n\nif (count !== state.get(\"count\")) {\n    list = [];\n    state.set(\"count\", count);\n}\n\nif (isDefined(val)) {\n    list.push(val);\n}\n\n\nstate.set(\"list\", list);\n\nif (list.length === state.get(\"count\")) {\n    r.next(list);\n}"
    },
    "AccumulateSome": {
        "id": "AccumulateSome",
        "inputs": {
            "count": {
                "mode": "required",
                "type": "any"
            },
            "allow": {
                "mode": "optional",
                "type": "any"
            },
            "filter": {
                "mode": "optional",
                "type": "any"
            }
        },
        "outputs": {
            "r": {
                "type": "any"
            }
        },
        "completionOutputs": [
            "r"
        ],
        "reactiveInputs": [
            "allow",
            "filter"
        ],
        "fnCode": "const {count, allow, filter} = inputs;\nconst {r} = outputs;\n\nconst {state} = adv;\n\nlet allowedList = state.get(\"allowed-list\") || [];\nlet filterList = state.get(\"filter-list\") || [];\n\nif (count !== state.get(\"count\")) {\n    state.set(\"count\", count);\n}\n\nif (isDefined(allow)) {\n    allowedList.push(allow);\n}\n\nif (isDefined(filter)) {\n    filterList.push(filter);\n}\n\nstate.set(\"allowed-list\", allowedList);\nstate.set(\"filter-list\", filterList);\n\nif (allowedList.length + filterList.length === state.get(\"count\")) {\n    r.next(allowedList);\n}\n"
    },
    "AccumulateUntil": {
        "id": "AccumulateUntil",
        "inputs": {
            "item": {
                "mode": "optional",
                "type": "any"
            },
            "until": {
                "mode": "optional",
                "type": "any"
            }
        },
        "outputs": {
            "r": {
                "type": "any"
            }
        },
        "completionOutputs": [
            "r"
        ],
        "reactiveInputs": [
            "item",
            "until"
        ],
        "fnCode": "// magic here\nconst {item, until} = inputs;\nconst {r} = outputs;\nconst {state} = adv;\n\nlet list = state.get(\"list\") || [];\n\n    if (isDefined(item)) {\n      list.push(item);\n      state.set(\"list\", list);\n    }\n\n    if (isDefined(until)) {\n      r.next(list);\n    }"
    },
    "AccumulateUntilTime": {
        "id": "AccumulateUntilTime",
        "inputs": {
            "time": {
                "mode": "required",
                "type": "any"
            },
            "item": {
                "mode": "optional",
                "type": "any"
            }
        },
        "outputs": {
            "r": {
                "type": "any"
            }
        },
        "completionOutputs": [
            "r"
        ],
        "reactiveInputs": [
            "item"
        ],
        "fnCode": "const {item, time} = inputs;\nconst {r} = outputs;\nconst {state} = adv;\n\n\nlet list = state.get(\"list\") || [];\nif (isDefined(item)) {\n  list.push(item);\n  state.set(\"list\", list);\n\n  const timer = state.get(\"timer\");\n  \n  if (timer) {\n    clearTimeout(timer);\n  } \n  \n  const newTimer = setTimeout(() => {\n      r.next(state.get(\"list\") || []);\n  }, time);\n  \n  state.set(\"timer\", newTimer)\n}\n\n\n"
    },
    "Add": {
        "id": "Add",
        "inputs": {
            "n1": {
                "mode": "required",
                "type": "any"
            },
            "n2": {
                "mode": "required",
                "type": "any"
            }
        },
        "outputs": {
            "r": {
                "type": "any"
            }
        },
        "completionOutputs": [
            "r"
        ],
        "fnCode": "const {n1, n2} = inputs;\nconst {r} = outputs;\n\nlog({n1, n2})\nr.next( n1 + n2 );"
    },
    "CollectionCountDocuments": {
        "id": "CollectionCountDocuments",
        "inputs": {
            "options": {
                "mode": "optional",
                "type": "any"
            },
            "collectionName": {
                "mode": "required",
                "type": "any"
            },
            "filter": {
                "mode": "required",
                "type": "any"
            },
            "": {
                "mode": "optional",
                "type": "any"
            }
        },
        "outputs": {
            "count": {
                "type": "any"
            }
        },
        "completionOutputs": [
            "count"
        ],
        "fnCode": "// magic here\nmongoDb\n    .collection(inputs.collectionName)\n    .countDocuments(inputs.filter, inputs.options)\n    .then((count) => {\n        outputs.count.next(count);\n    });"
    },
    "CollectionDeleteOne": {
        "id": "CollectionDeleteOne",
        "inputs": {
            "collectionName": {
                "mode": "required",
                "type": "any"
            },
            "filter": {
                "mode": "required",
                "type": "any"
            },
            "options": {
                "mode": "optional",
                "type": "any"
            }
        },
        "outputs": {
            "result": {
                "type": "any"
            }
        },
        "completionOutputs": [
            "result"
        ],
        "fnCode": "mongoDb.collection(inputs.collectionName)\n    .deleteOne(inputs.filter, inputs.options)\n    .then(res => {\n        outputs.result.next(res);\n    })\n    .catch((e) => adv.onError(e));"
    },
    "CollectionFind": {
        "id": "CollectionFind",
        "inputs": {
            "options": {
                "mode": "optional",
                "type": "any"
            },
            "collectionName": {
                "mode": "required",
                "type": "any"
            },
            "filter": {
                "mode": "required",
                "type": "any"
            }
        },
        "outputs": {
            "items": {
                "type": "any"
            }
        },
        "completionOutputs": [
            "items"
        ],
        "fnCode": "// magic here\nmongoDb\n    .collection(inputs.collectionName)\n    .find(inputs.filter, inputs.options)\n    .toArray()\n    .then((doc) => {\n        outputs.items.next(doc);\n    })\n    .catch((e) => adv.onError(e))"
    },
    "CollectionFindOne": {
        "id": "CollectionFindOne",
        "inputs": {
            "collectionName": {
                "mode": "required",
                "type": "any"
            },
            "filter": {
                "mode": "required",
                "type": "any"
            },
            "options": {
                "mode": "optional",
                "type": "any"
            }
        },
        "outputs": {
            "item": {
                "type": "any"
            }
        },
        "completionOutputs": [
            "item"
        ],
        "fnCode": "mongoDb.collection(inputs.collectionName)\n    .findOne(inputs.filter, inputs.options)\n    .then(res => {\n        if (res === null) {\n            adv.onError(new Error('not found'));\n        } else {\n            outputs.item.next(res);\n        }\n    })\n    .catch((e) => adv.onError(e));"
    },
    "CollectionFindOneAndUpdate": {
        "id": "CollectionFindOneAndUpdate",
        "inputs": {
            "options": {
                "mode": "optional",
                "type": "any"
            },
            "collectionName": {
                "mode": "required",
                "type": "any"
            },
            "filter": {
                "mode": "required",
                "type": "any"
            },
            "update": {
                "mode": "required",
                "type": "any"
            }
        },
        "outputs": {
            "updatedItem": {
                "type": "any"
            }
        },
        "completionOutputs": [
            "updatedItem"
        ],
        "fnCode": "// magic here\nconst options = inputs.options || {returnDocument: 'after'};\nmongoDb\n    .collection(inputs.collectionName)\n    .findOneAndUpdate(inputs.filter, inputs.update, options)\n    .then((doc) => {\n        outputs.updatedItem.next(doc);\n    });"
    },
    "CollectionInsertOne": {
        "id": "CollectionInsertOne",
        "inputs": {
            "collectionName": {
                "mode": "required",
                "type": "any"
            },
            "item": {
                "mode": "required",
                "type": "any"
            }
        },
        "outputs": {
            "success": {
                "type": "any"
            }
        },
        "completionOutputs": [
            "success"
        ],
        "fnCode": "// magic here\nmongoDb.collection(inputs.collectionName)\n    .insertOne(inputs.item)\n    .then(res => outputs.success.next({...inputs.item, _id: res.insertedId}))\n    .catch((e) => adv.onError(e));\n"
    },
    "concat": {
        "id": "concat",
        "inputs": {
            "a": {
                "mode": "required",
                "type": "any"
            },
            "b": {
                "mode": "required",
                "type": "any"
            }
        },
        "outputs": {
            "r": {
                "type": "object"
            }
        },
        "completionOutputs": [
            "r"
        ],
        "fnCode": "\n          let val = '\"${a}${b}\"';\n\n          Object.keys(inputs).forEach((key) => {\n\n            const _inpVal = inputs[key]; \n            const inpVal = typeof _inpVal === 'object' ? JSON.stringify(_inpVal) : _inpVal;\n\n            val = val\n              .replace('${' + key + '}', inpVal)\n              .replace('${' + key + '}', inpVal)\n              .replace('${' + key + '}', inpVal) // todo - support more than 3 instances in a nicer way\n          })\n          outputs.r.next(JSON.parse(val));"
    },
    "Cuid": {
        "id": "Cuid",
        "inputs": {
            "trigger": {
                "mode": "required",
                "type": "any"
            }
        },
        "outputs": {
            "r": {
                "type": "any"
            }
        },
        "completionOutputs": [
            "r"
        ],
        "fnCode": "// magic here\noutputs.r.next(cuid());"
    },
    "DbCount": {
        "id": "DbCount",
        "inputs": {
            "query": {
                "mode": "required",
                "type": "any"
            }
        },
        "outputs": {
            "count": {
                "type": "any"
            }
        },
        "completionOutputs": [
            "count"
        ],
        "fnCode": "// magic here\nconst {query} = inputs;\n\nconst {onError} = adv;\n\ndb.count(query)\n    .then(d => outputs.count.next(d))\n    .catch(err => {\n        onError(err);\n    });\n"
    },
    "DbFind": {
        "id": "DbFind",
        "inputs": {
            "query": {
                "mode": "required",
                "type": "any"
            },
            "sort": {
                "mode": "required-if-connected",
                "type": "any"
            },
            "limit": {
                "mode": "required-if-connected",
                "type": "any"
            },
            "skip": {
                "mode": "required-if-connected",
                "type": "any"
            }
        },
        "outputs": {
            "res": {
                "type": "any"
            },
            "err": {
                "type": "any"
            }
        },
        "fnCode": "// magic here\nconst {query, sort, limit, skip} = inputs;\ndb.find(query, sort || {}, Math.min(limit, 1000), {}, skip)\n    .then(d => outputs.res.next(d))\n    .catch(err => outputs.err.next(err.toString()));\n"
    },
    "DbFindOne": {
        "id": "DbFindOne",
        "inputs": {
            "query": {
                "mode": "required",
                "type": "any"
            }
        },
        "outputs": {
            "res": {
                "type": "any"
            }
        },
        "completionOutputs": [
            "res"
        ],
        "fnCode": "// magic here\ndb.findOne(inputs.query)\n    .then((doc) => {\n        if (isDefined(doc)) {\n            outputs.res.next(doc)\n        } else {\n            adv.onError('Not found');\n        }\n    })\n    .catch((err) => adv.onError(err))"
    },
    "DbInsert": {
        "id": "DbInsert",
        "inputs": {
            "doc": {
                "mode": "required",
                "type": "any"
            }
        },
        "outputs": {
            "ok": {
                "type": "any"
            },
            "err": {
                "type": "any"
            }
        },
        "fnCode": "// magic here\nlog('Going to insert doc')\nconst {onError} = adv;\n\ndb.insert(inputs.doc)\n    .then((doc) => {\n        log('Inserted doc')\n        outputs.ok.next(doc)\n    }, (err) => {\n        log('Failed to insert doc')\n        outputs.err.next(err);\n        onError(err);\n    });\n"
    },
    "DbRemove": {
        "id": "DbRemove",
        "inputs": {
            "query": {
                "mode": "required",
                "type": "any"
            },
            "options": {
                "mode": "required-if-connected",
                "type": "any"
            }
        },
        "outputs": {
            "ok": {
                "type": "any"
            },
            "err": {
                "type": "any"
            }
        },
        "fnCode": "// magic here\nconst {query, options} = inputs;\nconst {onError} = adv;\n\ndb.remove(query, isDefined(options) ? options : {})\n.then((num) => outputs.ok.next(num))\n.catch((err) => {\n    outputs.err.next(err)\n    onError(err);\n});\n\n"
    },
    "DbUpdate": {
        "id": "DbUpdate",
        "inputs": {
            "query": {
                "mode": "required",
                "type": "any"
            },
            "update": {
                "mode": "required",
                "type": "any"
            },
            "options": {
                "mode": "optional",
                "type": "any"
            }
        },
        "outputs": {
            "ok": {
                "type": "any"
            },
            "err": {
                "type": "any"
            }
        },
        "fnCode": "// magic here\nconst {query, update, options} = inputs;\nconst {ok, err} = outputs;\ndb.update(query, update, options)\n    .then((doc) => ok.next(doc))\n    .catch((e) => err.next(e));"
    },
    "Debounce": {
        "id": "Debounce",
        "inputs": {
            "i": {
                "mode": "required",
                "type": "any"
            },
            "ms": {
                "mode": "required",
                "type": "any"
            }
        },
        "outputs": {
            "r": {
                "type": "any"
            }
        },
        "customViewCode": "<% if (inputs.i) { %> Debounce  <%- inputs.i %>ms <% } else { %> Debounce <% } %>",
        "completionOutputs": [
            "r"
        ],
        "reactiveInputs": [
            "i"
        ],
        "fnCode": "const { i, ms } = inputs;\nconst { r } = outputs;\n        \n// magic here\nconst timer = adv.state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n\n  const newTimer = setTimeout(() => {\n    r.next(i);\n  }, ms);\n\n  adv.state.set(\"timer\", newTimer);\n\n  adv.onCleanup(() => {\n    clearTimeout(timer);\n  })"
    },
    "Delay": {
        "id": "Delay",
        "inputs": {
            "value": {
                "mode": "required",
                "type": "any"
            },
            "ms": {
                "mode": "required",
                "type": "any"
            }
        },
        "outputs": {
            "r": {
                "type": "any"
            }
        },
        "customViewCode": "",
        "completionOutputs": [
            "r"
        ],
        "fnCode": "// magic here\nconst {value, ms} = inputs;\n const timer = setTimeout(() => {\n    outputs.r.next(value);\n}, ms);\n\nadv.onCleanup(() => clearTimeout(timer));"
    },
    "Delay2": {
        "id": "Delay2",
        "inputs": {
            "value": {
                "mode": "required",
                "type": "any"
            },
            "ms": {
                "mode": "required",
                "type": "any"
            }
        },
        "outputs": {
            "r": {
                "type": "any"
            }
        },
        "customViewCode": "",
        "completionOutputs": [
            "r"
        ],
        "fnCode": "// magic here\nconst {value, ms} = inputs;\n const timer = setTimeout(() => {\n    outputs.r.next(value);\n}, ms);\n\nadv.onCleanup(() => clearTimeout(timer));"
    },
    "Divide": {
        "id": "Divide",
        "inputs": {
            "n1": {
                "mode": "required",
                "type": "any"
            },
            "n2": {
                "mode": "required",
                "type": "any"
            }
        },
        "outputs": {
            "r": {
                "type": "any"
            },
            "divByZero": {
                "type": "any"
            }
        },
        "fnCode": "const { n1, n2 } = inputs;\nconst { r, divByZero } = outputs;\n      \nif (n2 === 0) {\n      divByZero.next(n1);\n} else {\n      r.next(n1 / n2);\n}\n      "
    },
    "Dot": {
        "id": "Dot",
        "inputs": {
            "obj": {
                "mode": "required",
                "type": "any"
            },
            "key": {
                "mode": "required",
                "type": "any"
            }
        },
        "outputs": {
            "value": {
                "type": "any"
            }
        },
        "customViewCode": "<% if (inputs.key) { %> .<%- inputs.key %> <% } else { %> Dot <% } %>",
        "completionOutputs": [
            "value"
        ],
        "fnCode": "const { obj, key } = inputs;\nconst { value } = outputs;\n\n// magic here\n\nlet hadError = false;\n\nconst matches = {};\n\nconst normalized = key.replace(/\\[\"(([^\"])+)\"\\]/g, (match, p1, p2, offset) => {\n  const key = `__$$KEY$$__${offset}`;\n  matches[key] = p1;\n  return `.${key}`;\n});\n\nconst path = normalized.split(\".\");\nlet o = { ...obj };\nfor (let p of path) {\n  const key = matches[p] || p;\n  if (o && isDefined(o[key]) && o[key] !== null) {\n    o = o[key];\n  } else {\n    value.next(null);\n    hadError = true;\n  }\n}\n\nif (!hadError) {\n  value.next(o);\n}\n"
    },
    "EachMs": {
        "id": "EachMs",
        "inputs": {
            "ms": {
                "mode": "required",
                "type": "any"
            }
        },
        "outputs": {
            "r": {
                "type": "any"
            }
        },
        "completionOutputs": [
            "never"
        ],
        "fnCode": "const { ms } = inputs;\nconst { r } = outputs;\n        \n// magic here\nconst s = setInterval(() => {\n    r.next();\n}, ms);\n\nadv.onCleanup(() => {\n    clearInterval(s);\n})        "
    },
    "EmptyList": {
        "id": "EmptyList",
        "inputs": {},
        "outputs": {
            "list": {
                "type": "any"
            }
        },
        "completionOutputs": [
            "list"
        ],
        "fnCode": "// magic here\noutputs.list.next(\n    []\n);"
    },
    "EmptyObject": {
        "id": "EmptyObject",
        "inputs": {},
        "outputs": {
            "r": {
                "type": "any"
            }
        },
        "completionOutputs": [
            "r"
        ],
        "fnCode": "const {  } = inputs;\nconst { r } = outputs;\n        \n// magic here\nr.next({});"
    },
    "epochToString": {
        "id": "epochToString",
        "inputs": {
            "epoch": {
                "mode": "required",
                "type": "any"
            }
        },
        "outputs": {
            "r": {
                "type": "any"
            }
        },
        "completionOutputs": [
            "r"
        ],
        "fnCode": "// magic here\n\nconst d = new Date(inputs.epoch);\noutputs.r.next(d.toLocaleString());"
    },
    "Equals": {
        "id": "Equals",
        "inputs": {
            "val": {
                "mode": "required",
                "type": "any"
            },
            "compare": {
                "mode": "required",
                "type": "any"
            },
            "transform": {
                "mode": "required-if-connected",
                "type": "any"
            }
        },
        "outputs": {
            "r": {
                "type": "any"
            },
            "else": {
                "type": "any"
            }
        },
        "customViewCode": "<% if (inputs.compare) { %>Equals <%- inputs.compare %> <% } else { %> Equals <% } %>",
        "completionOutputs": [
            "r",
            "else"
        ],
        "fnCode": "const { val, compare, transform } = inputs;\nconst { r } = outputs;\n\nconst valueToPush = isDefined(transform) ? transform : val;\n        \n// magic here\nif (val === compare) {\n    r.next(valueToPush);\n}  else {\n    outputs['else'].next(valueToPush);\n}"
    },
    "FirstSecondOnlyRest": {
        "id": "FirstSecondOnlyRest",
        "inputs": {
            "list": {
                "mode": "required",
                "type": "any"
            }
        },
        "outputs": {
            "i0": {
                "type": "any"
            },
            "i1": {
                "type": "any"
            },
            "rest": {
                "type": "any"
            }
        },
        "fnCode": "const { list } = inputs;\nconst { i0, i1, rest } = outputs;\n      \nconst [_i0, _i1, ...r] = list;\n\n[i0, i1].forEach((o, idx) => {\n    if (typeof list[idx] !== 'undefined') {\n        o.next(list[idx]);\n    }\n});\n\nr.length && rest.next(r)\n      "
    },
    "FirstSecondRest": {
        "id": "FirstSecondRest",
        "inputs": {
            "list": {
                "mode": "required",
                "type": "any"
            }
        },
        "outputs": {
            "i0": {
                "type": "any"
            },
            "i1": {
                "type": "any"
            },
            "i2": {
                "type": "any"
            },
            "i3": {
                "type": "any"
            },
            "i4": {
                "type": "any"
            },
            "rest": {
                "type": "any"
            }
        },
        "fnCode": "const { list } = inputs;\nconst { i0, i1, i2, i3, i4, rest } = outputs;\n      \nconst [_i0, _i1, _i2, _i3, _i4, _i5, ...r] = list;\n\n[i0, i1, i2, i3, i4].forEach((o, idx) => {\n    if (typeof list[idx] !== 'undefined') {\n        o.next(list[idx]);\n    }\n});\n\nr.length && rest.next(r)\n      "
    },
    "FlattenArray": {
        "id": "FlattenArray",
        "inputs": {
            "arrayOfArrays": {
                "mode": "required",
                "type": "any"
            },
            "depth": {
                "mode": "required-if-connected",
                "type": "any"
            }
        },
        "outputs": {
            "array": {
                "type": "any"
            }
        },
        "completionOutputs": [
            "array"
        ],
        "fnCode": "// magic here\n\nconst flattened = inputs.arrayOfArrays.flat(inputs.depth || 1);\noutputs.array.next(flattened);"
    },
    "Floor": {
        "id": "Floor",
        "inputs": {
            "n": {
                "mode": "required",
                "type": "any"
            }
        },
        "outputs": {
            "r": {
                "type": "any"
            }
        },
        "completionOutputs": [
            "r"
        ],
        "fnCode": "const { n } = inputs;\nconst { r } = outputs;\n      \nr.next(Math.floor(n));\n      "
    },
    "FormatMessage": {
        "id": "FormatMessage",
        "inputs": {
            "template": {
                "mode": "required",
                "type": "any"
            },
            "var1": {
                "mode": "required",
                "type": "any"
            },
            "var2": {
                "mode": "required-if-connected",
                "type": "any"
            },
            "var3": {
                "mode": "required-if-connected",
                "type": "any"
            }
        },
        "outputs": {
            "r": {
                "type": "any"
            }
        },
        "completionOutputs": [
            "r"
        ],
        "fnCode": "const { template, var1, var2, var3 } = inputs;\nconst { r } = outputs;\n        \n// magic here\n const replaced = template\n    .replace(\"$VAL3\", var3)\n    .replace(\"$VAL2\", var2)\n    .replace(\"$VAL\", var1)\n    .replace(\"$VAR3\", var3)\n    .replace(\"$VAR2\", var2)\n    .replace(\"$VAR\", var1);\nr.next(replaced);"
    },
    "FormatModel": {
        "id": "FormatModel",
        "inputs": {
            "template": {
                "mode": "required",
                "type": "any"
            },
            "model": {
                "mode": "required",
                "type": "any"
            },
            "model2": {
                "mode": "required-if-connected",
                "type": "any"
            }
        },
        "outputs": {
            "r": {
                "type": "any"
            }
        },
        "completionOutputs": [
            "r"
        ],
        "fnCode": "const { template, model, model2 } = inputs;\nconst { r } = outputs;\n        \n// magic here\nconst combined = { ...model, ...(model2 || {}) };\n  const find = (_, key) => {\n    const path = key.split(\".\");\n    let o = { ...combined };\n    for (let p of path) {\n      if (o && o[p]) {\n        o = o[p];\n      } else {\n        return key;\n      }\n    }\n    return o;\n  };\n\nconst replaced = template\n  .replace(/\\$\\{([a-zA-Z \\d\\.]*)\\}/g, find)\n  .replace(/<%=([a-zA-Z \\d\\.]*)%>/g, find);\n\nr.next(replaced);"
    },
    "GetItem": {
        "id": "GetItem",
        "inputs": {
            "key": {
                "mode": "required",
                "type": "any"
            },
            "defaultValue": {
                "mode": "required-if-connected",
                "type": "any"
            }
        },
        "outputs": {
            "ok": {
                "type": "any"
            }
        },
        "completionOutputs": [
            "ok"
        ],
        "fnCode": "// magic here\nconst {ok, err} = outputs;\nconst {key, defaultValue} = inputs;\nconst {onError} = adv;\n\nmongoDb.collection('__KVStore').findOne({id: key})\n    .then((doc) => {\n        if (doc === null) {\n            if (isDefined(defaultValue)) {\n                ok.next(defaultValue);\n            } else {\n                onError(new Error('Key not found and no default value'));\n            }\n        } else {\n            ok.next(doc.value);\n        }\n    })\n    .catch((e) => {\n        onError(e);\n    });"
    },
    "GetListItem": {
        "id": "GetListItem",
        "inputs": {
            "list": {
                "mode": "required",
                "type": "any"
            },
            "idx": {
                "mode": "required",
                "type": "any"
            }
        },
        "outputs": {
            "r": {
                "type": "any"
            }
        },
        "completionOutputs": [
            "r"
        ],
        "fnCode": "// magic here\noutputs.r.next(inputs.list[inputs.idx]);"
    },
    "GetState": {
        "id": "GetState",
        "inputs": {
            "key": {
                "mode": "required",
                "type": "any"
            }
        },
        "outputs": {
            "r": {
                "type": "any"
            },
            "err": {
                "type": "any"
            }
        },
        "fnCode": "const {state} = adv;\nconst {key} = inputs;\nconst {r, err} = outputs;\n\nconst val = state.get(key);\nif (isDefined(val)) {\n    r.next(val);\n} else {\n    err.next(key);\n}\n"
    },
    "HeadCSS": {
        "id": "HeadCSS",
        "inputs": {
            "css": {
                "mode": "required",
                "type": "any"
            },
            "key": {
                "mode": "optional",
                "type": "any"
            }
        },
        "outputs": {},
        "fnCode": "try {\n    const document = getDocument();\n    const normKey = inputs.key || \"default-css\";\n    const tag = document.createElement(\"style\");\n    tag.innerHTML = inputs.css;\n    tag.id = normKey;\n    \n    const existing = document.getElementById(normKey);\n    if (existing) {\n      existing.remove();\n    }\n    document.head.appendChild(tag);\n} catch (e) {\n    log(`Unable to run head css node`, e);\n}"
    },
    "HtmlTag": {
        "id": "HtmlTag",
        "inputs": {
            "id": {
                "mode": "required-if-connected",
                "type": "any"
            },
            "style": {
                "mode": "required-if-connected",
                "type": "any"
            },
            "className": {
                "mode": "required-if-connected",
                "type": "any"
            },
            "tagName": {
                "mode": "required",
                "type": "any"
            },
            "extra": {
                "mode": "required-if-connected",
                "type": "any"
            },
            "children": {
                "mode": "required-if-connected",
                "type": "any"
            }
        },
        "outputs": {
            "jsx": {
                "type": "any"
            },
            "click": {
                "type": "any"
            }
        },
        "fnCode": "// magic here\nconst props = {\n    className: inputs.className,\n    id: inputs.id,\n    style: inputs.style\n}\n\nconst onClick = outputs.click ? (e) => outputs.click.next(e) : undefined;\nconst comp = React.createElement(inputs.tagName, {\n    ...props,\n    ...(inputs.extra || {}),\n    onClick\n}, inputs.children);\n\noutputs.jsx.next(comp);"
    },
    "HtmlValueTag": {
        "id": "HtmlValueTag",
        "inputs": {
            "id": {
                "mode": "required-if-connected",
                "type": "any"
            },
            "style": {
                "mode": "required-if-connected",
                "type": "any"
            },
            "className": {
                "mode": "required-if-connected",
                "type": "any"
            },
            "tagName": {
                "mode": "required",
                "type": "any"
            },
            "extra": {
                "mode": "required-if-connected",
                "type": "any"
            },
            "children": {
                "mode": "required-if-connected",
                "type": "any"
            },
            "value": {
                "mode": "required-if-connected",
                "type": "any"
            },
            "placeholder": {
                "mode": "required-if-connected",
                "type": "any"
            }
        },
        "outputs": {
            "jsx": {
                "type": "any"
            },
            "click": {
                "type": "any"
            },
            "change": {
                "type": "any"
            }
        },
        "fnCode": "// magic here\nconst props = {\n    className: inputs.className,\n    id: inputs.id,\n    style: inputs.style\n}\n\nconst onClick = outputs.click ? (e) => outputs.click.next(e) : undefined;\nconst onChange = outputs.change ? (e) => outputs.change.next(e.target.value) : undefined;\nconst comp = React.createElement(inputs.tagName, {\n    ...props,\n    ...(inputs.extra || {}),\n    onClick,\n    onChange\n}, inputs.children);\n\noutputs.jsx.next(comp);"
    },
    "HttpGet": {
        "id": "HttpGet",
        "inputs": {
            "url": {
                "mode": "required",
                "type": "any"
            },
            "headers": {
                "mode": "required-if-connected",
                "type": "any"
            }
        },
        "outputs": {
            "r": {
                "type": "any"
            }
        },
        "completionOutputs": [
            "r"
        ],
        "fnCode": "const { url, headers } = inputs;\nconst { r, error } = outputs;\n\nconst {onError} = adv;\n        \n// magic here\naxios.get(url, { headers, timeout: DEFAULT_AXIOS_TIMEOUT }).then((res) => {\n    r.next(res.data);\n}, (err) => {\n    onError(err);\n});"
    },
    "HttpPost": {
        "id": "HttpPost",
        "inputs": {
            "url": {
                "mode": "required",
                "type": "any"
            },
            "body": {
                "mode": "required",
                "type": "any"
            },
            "headers": {
                "mode": "required-if-connected",
                "type": "any"
            },
            "bodyType": {
                "mode": "required-if-connected",
                "type": "any"
            }
        },
        "outputs": {
            "r": {
                "type": "any"
            },
            "e": {
                "type": "any"
            }
        },
        "fnCode": "const { url, body, headers, bodyType } = inputs;\nconst { r, e } = outputs;\n\nconst {onError} = adv;\n\nconst config = {\n    headers,\n    timeout: DEFAULT_AXIOS_TIMEOUT\n}\n        \n// magic here\nif (bodyType === \"form\") {\n    const parts = [];\n    Object.keys(body).forEach((key) => {\n      parts.push(`${key}=${encodeURIComponent(body[key])}`);\n    });\n    axios.post(url, parts.join(\"&\"), config).then(\n      (res) => {\n        r.next(res.data);\n      },\n      (err) => {\n        const {response, message} = err;\n        const errorObj = response ? {data:response.data, status: response.status} : {data: message, status: -1};\n        e.next(errorObj)\n        onError(errorObj);\n      }\n    );\n  } else {\n    axios.post(url, body, config).then(\n      (res) => {\n        r.next(res.data);\n      },\n      (err) => {\n        const {response, message} = err;\n        const errorObj = response ? {data:response.data, status: response.status} : {data: message, status: -1};\n        e.next(errorObj)\n        onError(errorObj);\n      }\n    );\n  }"
    },
    "HttpRequest": {
        "id": "HttpRequest",
        "inputs": {
            "url": {
                "mode": "required",
                "type": "any"
            },
            "method": {
                "mode": "required",
                "type": "any"
            },
            "headers": {
                "mode": "required-if-connected",
                "type": "any"
            },
            "data": {
                "mode": "required-if-connected",
                "type": "any"
            }
        },
        "outputs": {
            "r": {
                "type": "any"
            }
        },
        "completionOutputs": [
            "r"
        ],
        "fnCode": "const { url, headers, method, data } = inputs;\nconst { r } = outputs;\n\nconst {onError} = adv;\n        \n// magic here\naxios({ url, method, data, headers, timeout: DEFAULT_AXIOS_TIMEOUT }).then((res) => {\n    r.next(res.data);\n}, (err) => {\n    onError(err);\n});"
    },
    "Id": {
        "id": "Id",
        "inputs": {
            "v": {
                "mode": "required",
                "type": "any"
            }
        },
        "outputs": {
            "r": {
                "type": "object"
            }
        },
        "customViewCode": "",
        "completionOutputs": [
            "r"
        ],
        "fnCode": "outputs.r.next(inputs.v)"
    },
    "IndexOf": {
        "id": "IndexOf",
        "inputs": {
            "str": {
                "mode": "required",
                "type": "any"
            },
            "char": {
                "mode": "required",
                "type": "any"
            }
        },
        "outputs": {
            "r": {
                "type": "any"
            },
            "notFound": {
                "type": "any"
            }
        },
        "fnCode": "const { str, char } = inputs;\nconst { r, notFound } = outputs;\n        \n// magic here\nconst i = str.indexOf(char);\nif (i !== -1) {\n    r.next(str.indexOf(char));\n} else {\n    notFound.next(str);\n}  "
    },
    "IsEmpty": {
        "id": "IsEmpty",
        "inputs": {
            "str": {
                "mode": "required",
                "type": "any"
            }
        },
        "outputs": {
            "true": {
                "type": "any"
            },
            "false": {
                "type": "any"
            }
        },
        "fnCode": "const { str } = inputs;\n        \n// magic here\nif (str === \"\") {\n    outputs.true.next(str);\n} else {\n    outputs.false.next(str);\n}"
    },
    "IsGreater bool ": {
        "id": "IsGreater bool ",
        "inputs": {
            "n1": {
                "mode": "required",
                "type": "any"
            },
            "n2": {
                "mode": "required",
                "type": "any"
            },
            "transform": {
                "mode": "required-if-connected",
                "type": "any"
            }
        },
        "outputs": {
            "result": {
                "type": "any"
            }
        },
        "customViewCode": "<% if (inputs.n2) { %>  > <%- inputs.n2 %> <% } else { %> Is Greater <% } %>",
        "fnCode": "const { n1, n2, transform} = inputs;\n\n\noutputs.result.next(n1 > n2);\n      "
    },
    "IsGreater": {
        "id": "IsGreater",
        "inputs": {
            "n1": {
                "mode": "required",
                "type": "any"
            },
            "n2": {
                "mode": "required",
                "type": "any"
            },
            "transform": {
                "mode": "required-if-connected",
                "type": "any"
            }
        },
        "outputs": {
            "true": {
                "type": "any"
            },
            "false": {
                "type": "any"
            }
        },
        "customViewCode": "<% if (inputs.n2) { %>  > <%- inputs.n2 %> <% } else { %> Is Greater <% } %>",
        "fnCode": "const { n1, n2, transform} = inputs;\n\n\n      \nif (n1 > n2) {\n      outputs.true.next(isDefined(transform) ? transform : n1);\n} else {\n      outputs.false.next(isDefined(transform) ? transform : n2);\n}\n// magic here\n      "
    },
    "isLess bool": {
        "id": "isLess bool",
        "inputs": {
            "n1": {
                "mode": "required",
                "type": "any"
            },
            "n2": {
                "mode": "required",
                "type": "any"
            },
            "transform": {
                "mode": "required-if-connected",
                "type": "any"
            }
        },
        "outputs": {
            "result": {
                "type": "any"
            }
        },
        "customViewCode": "<% if (inputs.n2) { %>  < <%- inputs.n2 %> <% } else { %> Is Less <% } %>",
        "fnCode": "const { n1, n2, transform} = inputs;\n\n\noutputs.result.next(n1 < n2);\n      "
    },
    "isLess": {
        "id": "isLess",
        "inputs": {
            "n1": {
                "mode": "required",
                "type": "any"
            },
            "n2": {
                "mode": "required",
                "type": "any"
            }
        },
        "outputs": {
            "true": {
                "type": "any"
            },
            "false": {
                "type": "any"
            }
        },
        "customViewCode": "",
        "completionOutputs": [
            "true",
            "false"
        ],
        "fnCode": "const { n1, n2 } = inputs;\n      \nif (n1 < n2) {\n      outputs.true.next(n1);\n} else {\n      outputs.false.next(n1);\n}\n// magic here\n      "
    },
    "isPropertyGreater": {
        "id": "isPropertyGreater",
        "inputs": {
            "obj": {
                "mode": "required",
                "type": "any"
            },
            "key": {
                "mode": "required",
                "type": "any"
            },
            "value": {
                "mode": "required",
                "type": "any"
            }
        },
        "outputs": {
            "true": {
                "type": "any"
            },
            "false": {
                "type": "any"
            }
        },
        "customViewCode": "<% if (inputs.key && inputs.value) { %>  .<%- inputs.key %> > <%- inputs.value %> <% } else { %> Is Property Greater <% } %>",
        "fnCode": "const objVal = inputs.obj[inputs.key];\n\nif (objVal > inputs.value) {\n    outputs.true.next(inputs.obj)\n} else {\n    outputs.false.next(inputs.obj)\n}"
    },
    "LimitTimes": {
        "id": "LimitTimes",
        "inputs": {
            "item": {
                "mode": "required",
                "type": "any"
            },
            "times": {
                "mode": "required",
                "type": "any"
            }
        },
        "outputs": {
            "ok": {
                "type": "any"
            },
            "breach": {
                "type": "any"
            }
        },
        "completionOutputs": [
            "breach"
        ],
        "reactiveInputs": [
            "item"
        ],
        "fnCode": "// magic here\nconst {state} = adv;\nconst {item, times} = inputs;\nconst {ok, breach} = outputs;\n\nlet curr = state.get('val') || 0;\ncurr++;\nstate.set('val', curr);\nif (curr >= times) {\n    breach.next(item);\n} else {\n    ok.next(item);\n}\n"
    },
    "ListAppend": {
        "id": "ListAppend",
        "inputs": {
            "list": {
                "mode": "required",
                "type": "any"
            },
            "item": {
                "mode": "required",
                "type": "any"
            }
        },
        "outputs": {
            "r": {
                "type": "any"
            }
        },
        "completionOutputs": [
            "r"
        ],
        "fnCode": "// magic here// magic here\noutputs.r.next(\n    [...inputs.list, inputs.item]\n);"
    },
    "ListConcat2": {
        "id": "ListConcat2",
        "inputs": {
            "list1": {
                "mode": "required",
                "type": "any"
            },
            "list2": {
                "mode": "required",
                "type": "any"
            }
        },
        "outputs": {
            "r": {
                "type": "any"
            }
        },
        "completionOutputs": [
            "r"
        ],
        "fnCode": "// magic here\nconst {list1, list2} = inputs;\noutputs.r.next(list1.concat(list2));"
    },
    "ListFilter": {
        "id": "ListFilter",
        "inputs": {
            "list": {
                "mode": "required",
                "type": "any"
            },
            "fn": {
                "mode": "required",
                "type": "node({\"item\": \"any\", \"idx?\": \"any\"}|{\"allow\": \"any\", \"block\": \"any\"})"
            }
        },
        "outputs": {
            "r": {
                "type": "any"
            }
        },
        "completionOutputs": [
            "r"
        ],
        "fnCode": "const o = outputs;\nconst {list, fn} = inputs;\n\nconst allowSet = new Set();\nconst blockSet = new Set();\nconst newList = [];\n\nconst uns = [];\n\nconst maybeSendNewList = () => {\n  if (allowSet.size + blockSet.size === list.length) {\n    o.r.next(newList.filter((item) => item !== undefined));\n  }\n};\n\nlist.forEach((item, idx) => {\n  const itemInput = dynamicNodeInput();\n  const idxInput = dynamicNodeInput();\n  const outputs = Object.keys(fn.outputs).reduce(\n    (p, k) => ({ ...p, [k]: dynamicOutput() }),\n    {}\n  );\n  outputs.allow.subscribe(() => {\n    newList.push(item);\n    allowSet.add(idx);\n    maybeSendNewList();\n  });\n\n  outputs.block.subscribe(() => {\n    blockSet.add(idx);\n    maybeSendNewList();\n  });\n\n  Object.keys(outputs)\n    .filter((k) => k !== \"allow\" && k !== \"block\")\n    .forEach((k) => {\n      outputs[k].subscribe(() => {\n        o.rs.next({ key: k, v: item, idx });\n      });\n    });\n  const clean = adv.execute(\n    fn,\n    { item: itemInput, idx: idxInput },\n    outputs,\n    `${adv.insId}-fn`\n  );\n\n  idxInput.subject.next(idx);\n  itemInput.subject.next(item);\n  uns.push(clean);\n});\n\nadv.onCleanup(() => {\n  uns.forEach((fn) => fn());\n});\n"
    },
    "ListFrom2": {
        "id": "ListFrom2",
        "inputs": {
            "item1": {
                "mode": "required",
                "type": "any"
            },
            "item2": {
                "mode": "required",
                "type": "any"
            }
        },
        "outputs": {
            "list": {
                "type": "any"
            }
        },
        "completionOutputs": [
            "list"
        ],
        "fnCode": "// magic here\noutputs.list.next(\n    [\n        inputs.item1,\n        inputs.item2\n    ]\n);"
    },
    "ListFrom3": {
        "id": "ListFrom3",
        "inputs": {
            "item1": {
                "mode": "required",
                "type": "any"
            },
            "item2": {
                "mode": "required",
                "type": "any"
            },
            "item3": {
                "mode": "required",
                "type": "any"
            }
        },
        "outputs": {
            "list": {
                "type": "any"
            }
        },
        "completionOutputs": [
            "list"
        ],
        "fnCode": "// magic here\noutputs.list.next(\n    [\n        inputs.item1,\n        inputs.item2,\n        inputs.item3\n    ]\n);"
    },
    "ListFromStr": {
        "id": "ListFromStr",
        "inputs": {
            "count": {
                "mode": "required",
                "type": "any"
            },
            "char": {
                "mode": "required",
                "type": "any"
            }
        },
        "outputs": {
            "r": {
                "type": "any"
            }
        },
        "completionOutputs": [
            "r"
        ],
        "fnCode": "// magic here\n\noutputs\n    .r\n    .next(new Array(inputs.count).fill(inputs.char));"
    },
    "ListJoin": {
        "id": "ListJoin",
        "inputs": {
            "list": {
                "mode": "required",
                "type": "any"
            },
            "delimiter": {
                "mode": "required",
                "type": "any"
            }
        },
        "outputs": {
            "r": {
                "type": "any"
            }
        },
        "completionOutputs": [
            "r"
        ],
        "fnCode": "const { list, delimiter } = inputs;\nconst { r } = outputs;\n        \n// magic here\nr.next(list.join(delimiter));"
    },
    "ListLength": {
        "id": "ListLength",
        "inputs": {
            "list": {
                "mode": "required",
                "type": "any"
            }
        },
        "outputs": {
            "length": {
                "type": "any"
            }
        },
        "completionOutputs": [
            "length"
        ],
        "fnCode": "// magic here\noutputs.length.next(inputs.list.length);"
    },
    "ListMap": {
        "id": "ListMap",
        "inputs": {
            "list": {
                "mode": "required",
                "type": "any"
            },
            "fn": {
                "mode": "required",
                "type": "node({\"item?\": \"any\", \"idx?\": \"any\"}|{\"r\": \"any\", \"rs\": \"any\"})"
            }
        },
        "outputs": {
            "r": {
                "type": "any"
            },
            "rs": {
                "type": "any"
            }
        },
        "fnCode": "let newList = [];\n\nconst { list, fn} = inputs;\nconst o = outputs;\n\nlet received = new Set();\n\nconst cleanUps = [];\n\nlist.forEach((item, idx) => {\n  const itemInput = dynamicNodeInput();\n  const idxInput = dynamicNodeInput();\n  const mainOutput = dynamicOutput();\n  const sideOutput = dynamicOutput();\n  mainOutput.subscribe((receivedItem) => {\n    newList[idx] = receivedItem;\n    received.add(idx);\n    if (received.size === list.length) {\n      o.r.next(newList);\n    }\n  });\n\n  sideOutput.subscribe((v) => {\n    o.rs.next(v);\n  });\n\n  const clean = adv.execute(\n    fn,\n    { item: itemInput, idx: idxInput },\n    { r: mainOutput, rs: sideOutput },\n    `${adv.insId}-fn`\n  );\n\n  cleanUps.push(clean);\n\n  itemInput.subject.next(item);\n  idxInput.subject.next(idx);\n});\n\nif (list.length === 0) {\n  o.r.next(list);\n}\n\nadv.onCleanup(() => {\n  cleanUps.forEach((fn) => fn());\n});\n"
    },
    "ListPrepend": {
        "id": "ListPrepend",
        "inputs": {
            "list": {
                "mode": "required",
                "type": "any"
            },
            "item": {
                "mode": "required",
                "type": "any"
            }
        },
        "outputs": {
            "r": {
                "type": "any"
            }
        },
        "completionOutputs": [
            "r"
        ],
        "fnCode": "// magic here// magic here\noutputs.r.next(\n    [inputs.item, ...inputs.list]\n);"
    },
    "MathMin": {
        "id": "MathMin",
        "inputs": {
            "n1": {
                "mode": "required",
                "type": "any"
            },
            "n2": {
                "mode": "required",
                "type": "any"
            }
        },
        "outputs": {
            "r": {
                "type": "any"
            }
        },
        "completionOutputs": [
            "r"
        ],
        "fnCode": "const { n1, n2 } = inputs;\n      \noutputs.r.next(Math.min(n1, n2));\n// magic here\n      "
    },
    "MD5HashString": {
        "id": "MD5HashString",
        "inputs": {
            "str": {
                "mode": "required",
                "type": "any"
            }
        },
        "outputs": {
            "r": {
                "type": "any"
            }
        },
        "completionOutputs": [
            "r"
        ],
        "fnCode": "function md5cycle(x, k) {\n  var a = x[0],\n    b = x[1],\n    c = x[2],\n    d = x[3];\n\n  a = ff(a, b, c, d, k[0], 7, -680876936);\n  d = ff(d, a, b, c, k[1], 12, -389564586);\n  c = ff(c, d, a, b, k[2], 17, 606105819);\n  b = ff(b, c, d, a, k[3], 22, -1044525330);\n  a = ff(a, b, c, d, k[4], 7, -176418897);\n  d = ff(d, a, b, c, k[5], 12, 1200080426);\n  c = ff(c, d, a, b, k[6], 17, -1473231341);\n  b = ff(b, c, d, a, k[7], 22, -45705983);\n  a = ff(a, b, c, d, k[8], 7, 1770035416);\n  d = ff(d, a, b, c, k[9], 12, -1958414417);\n  c = ff(c, d, a, b, k[10], 17, -42063);\n  b = ff(b, c, d, a, k[11], 22, -1990404162);\n  a = ff(a, b, c, d, k[12], 7, 1804603682);\n  d = ff(d, a, b, c, k[13], 12, -40341101);\n  c = ff(c, d, a, b, k[14], 17, -1502002290);\n  b = ff(b, c, d, a, k[15], 22, 1236535329);\n\n  a = gg(a, b, c, d, k[1], 5, -165796510);\n  d = gg(d, a, b, c, k[6], 9, -1069501632);\n  c = gg(c, d, a, b, k[11], 14, 643717713);\n  b = gg(b, c, d, a, k[0], 20, -373897302);\n  a = gg(a, b, c, d, k[5], 5, -701558691);\n  d = gg(d, a, b, c, k[10], 9, 38016083);\n  c = gg(c, d, a, b, k[15], 14, -660478335);\n  b = gg(b, c, d, a, k[4], 20, -405537848);\n  a = gg(a, b, c, d, k[9], 5, 568446438);\n  d = gg(d, a, b, c, k[14], 9, -1019803690);\n  c = gg(c, d, a, b, k[3], 14, -187363961);\n  b = gg(b, c, d, a, k[8], 20, 1163531501);\n  a = gg(a, b, c, d, k[13], 5, -1444681467);\n  d = gg(d, a, b, c, k[2], 9, -51403784);\n  c = gg(c, d, a, b, k[7], 14, 1735328473);\n  b = gg(b, c, d, a, k[12], 20, -1926607734);\n\n  a = hh(a, b, c, d, k[5], 4, -378558);\n  d = hh(d, a, b, c, k[8], 11, -2022574463);\n  c = hh(c, d, a, b, k[11], 16, 1839030562);\n  b = hh(b, c, d, a, k[14], 23, -35309556);\n  a = hh(a, b, c, d, k[1], 4, -1530992060);\n  d = hh(d, a, b, c, k[4], 11, 1272893353);\n  c = hh(c, d, a, b, k[7], 16, -155497632);\n  b = hh(b, c, d, a, k[10], 23, -1094730640);\n  a = hh(a, b, c, d, k[13], 4, 681279174);\n  d = hh(d, a, b, c, k[0], 11, -358537222);\n  c = hh(c, d, a, b, k[3], 16, -722521979);\n  b = hh(b, c, d, a, k[6], 23, 76029189);\n  a = hh(a, b, c, d, k[9], 4, -640364487);\n  d = hh(d, a, b, c, k[12], 11, -421815835);\n  c = hh(c, d, a, b, k[15], 16, 530742520);\n  b = hh(b, c, d, a, k[2], 23, -995338651);\n\n  a = ii(a, b, c, d, k[0], 6, -198630844);\n  d = ii(d, a, b, c, k[7], 10, 1126891415);\n  c = ii(c, d, a, b, k[14], 15, -1416354905);\n  b = ii(b, c, d, a, k[5], 21, -57434055);\n  a = ii(a, b, c, d, k[12], 6, 1700485571);\n  d = ii(d, a, b, c, k[3], 10, -1894986606);\n  c = ii(c, d, a, b, k[10], 15, -1051523);\n  b = ii(b, c, d, a, k[1], 21, -2054922799);\n  a = ii(a, b, c, d, k[8], 6, 1873313359);\n  d = ii(d, a, b, c, k[15], 10, -30611744);\n  c = ii(c, d, a, b, k[6], 15, -1560198380);\n  b = ii(b, c, d, a, k[13], 21, 1309151649);\n  a = ii(a, b, c, d, k[4], 6, -145523070);\n  d = ii(d, a, b, c, k[11], 10, -1120210379);\n  c = ii(c, d, a, b, k[2], 15, 718787259);\n  b = ii(b, c, d, a, k[9], 21, -343485551);\n\n  x[0] = add32(a, x[0]);\n  x[1] = add32(b, x[1]);\n  x[2] = add32(c, x[2]);\n  x[3] = add32(d, x[3]);\n}\n\nfunction cmn(q, a, b, x, s, t) {\n  a = add32(add32(a, q), add32(x, t));\n  return add32((a << s) | (a >>> (32 - s)), b);\n}\n\nfunction ff(a, b, c, d, x, s, t) {\n  return cmn((b & c) | (~b & d), a, b, x, s, t);\n}\n\nfunction gg(a, b, c, d, x, s, t) {\n  return cmn((b & d) | (c & ~d), a, b, x, s, t);\n}\n\nfunction hh(a, b, c, d, x, s, t) {\n  return cmn(b ^ c ^ d, a, b, x, s, t);\n}\n\nfunction ii(a, b, c, d, x, s, t) {\n  return cmn(c ^ (b | ~d), a, b, x, s, t);\n}\n\nfunction md51(s) {\n  txt = \"\";\n  var n = s.length,\n    state = [1732584193, -271733879, -1732584194, 271733878],\n    i;\n  for (i = 64; i <= s.length; i += 64) {\n    md5cycle(state, md5blk(s.substring(i - 64, i)));\n  }\n  s = s.substring(i - 64);\n  var tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n  for (i = 0; i < s.length; i++)\n    tail[i >> 2] |= s.charCodeAt(i) << (i % 4 << 3);\n  tail[i >> 2] |= 0x80 << (i % 4 << 3);\n  if (i > 55) {\n    md5cycle(state, tail);\n    for (i = 0; i < 16; i++) tail[i] = 0;\n  }\n  tail[14] = n * 8;\n  md5cycle(state, tail);\n  return state;\n}\n\n/* there needs to be support for Unicode here,\n * unless we pretend that we can redefine the MD-5\n * algorithm for multi-byte characters (perhaps\n * by adding every four 16-bit characters and\n * shortening the sum to 32 bits). Otherwise\n * I suggest performing MD-5 as if every character\n * was two bytes--e.g., 0040 0025 = @%--but then\n * how will an ordinary MD-5 sum be matched?\n * There is no way to standardize text to something\n * like UTF-8 before transformation; speed cost is\n * utterly prohibitive. The JavaScript standard\n * itself needs to look at this: it should start\n * providing access to strings as preformed UTF-8\n * 8-bit unsigned value arrays.\n */\nfunction md5blk(s) {\n  /* I figured global was faster.   */\n  var md5blks = [],\n    i; /* Andy King said do it this way. */\n  for (i = 0; i < 64; i += 4) {\n    md5blks[i >> 2] =\n      s.charCodeAt(i) +\n      (s.charCodeAt(i + 1) << 8) +\n      (s.charCodeAt(i + 2) << 16) +\n      (s.charCodeAt(i + 3) << 24);\n  }\n  return md5blks;\n}\n\nvar hex_chr = \"0123456789abcdef\".split(\"\");\n\nfunction rhex(n) {\n  var s = \"\",\n    j = 0;\n  for (; j < 4; j++)\n    s += hex_chr[(n >> (j * 8 + 4)) & 0x0f] + hex_chr[(n >> (j * 8)) & 0x0f];\n  return s;\n}\n\nfunction hex(x) {\n  for (var i = 0; i < x.length; i++) x[i] = rhex(x[i]);\n  return x.join(\"\");\n}\n\nfunction md5(s) {\n  return hex(md51(s));\n}\n\nfunction add32(a, b) {\n  return (a + b) & 0xffffffff;\n}\n\noutputs.r.next(md5(inputs.str));\n"
    },
    "MergeObjects": {
        "id": "MergeObjects",
        "inputs": {
            "obj1": {
                "mode": "required",
                "type": "any"
            },
            "obj2": {
                "mode": "required",
                "type": "any"
            }
        },
        "outputs": {
            "r": {
                "type": "any"
            }
        },
        "completionOutputs": [
            "r"
        ],
        "fnCode": "// magic here\nconst {obj1, obj2} = inputs;\noutputs.r.next({...obj1, ...obj2});"
    },
    "MillisToDateString": {
        "id": "MillisToDateString",
        "inputs": {
            "ms": {
                "mode": "required",
                "type": "any"
            },
            "locale": {
                "mode": "required-if-connected",
                "type": "any"
            },
            "options": {
                "mode": "required-if-connected",
                "type": "any"
            }
        },
        "outputs": {
            "dateString": {
                "type": "any"
            }
        },
        "completionOutputs": [
            "dateString"
        ],
        "fnCode": "// magic here\n\nconst {ms, locale, options} = inputs;\nconst {dateString} = outputs;\n\nconst _locale = locale || 'en-US';\nconst _options = options || {};\n\nconst str = new Date(ms).toLocaleDateString(_locale, _options);\n\ndateString.next(str);"
    },
    "MillisToString": {
        "id": "MillisToString",
        "inputs": {
            "ms": {
                "mode": "required",
                "type": "any"
            },
            "locale": {
                "mode": "required-if-connected",
                "type": "any"
            },
            "options": {
                "mode": "required-if-connected",
                "type": "any"
            }
        },
        "outputs": {
            "dateString": {
                "type": "any"
            }
        },
        "completionOutputs": [
            "dateString"
        ],
        "fnCode": "// magic here\n\nconst {ms, locale, options} = inputs;\nconst {dateString} = outputs;\n\nconst _locale = locale || 'en-US';\nconst _options = options || {};\n\nconst str = new Date(ms).toLocaleString(_locale, _options);\n\ndateString.next(str);"
    },
    "Modulo": {
        "id": "Modulo",
        "inputs": {
            "n1": {
                "mode": "required",
                "type": "any"
            },
            "n2": {
                "mode": "required",
                "type": "any"
            }
        },
        "outputs": {
            "r": {
                "type": "any"
            }
        },
        "completionOutputs": [
            "r"
        ],
        "fnCode": "const { n1, n2 } = inputs;\nconst { r } = outputs;\n      \n// magic here\nr.next(n1 % n2);\n      "
    },
    "MouseEvent": {
        "id": "MouseEvent",
        "inputs": {},
        "outputs": {
            "event": {
                "type": "any"
            }
        },
        "completionOutputs": [
            "never"
        ],
        "fnCode": "getDocument().body.addEventListener('mousemove', ev => {\n  outputs.event.next(ev);\n})"
    },
    "Multiply": {
        "id": "Multiply",
        "inputs": {
            "n1": {
                "mode": "required",
                "type": "any"
            },
            "n2": {
                "mode": "required",
                "type": "any"
            }
        },
        "outputs": {
            "r": {
                "type": "any"
            }
        },
        "completionOutputs": [
            "r"
        ],
        "fnCode": "const { n1, n2 } = inputs;\nconst { r } = outputs;\n      \n// magic here\nr.next(n1 * n2);\n      "
    },
    "Now": {
        "id": "Now",
        "inputs": {
            "trigger": {
                "mode": "optional",
                "type": "any"
            }
        },
        "outputs": {
            "r": {
                "type": "any"
            }
        },
        "completionOutputs": [
            "r"
        ],
        "fnCode": "const { trigger } = inputs;\nconst { r } = outputs;\n        \n// magic here\nr.next(Date.now());\n        "
    },
    "Object-builder-75360": {
        "id": "Object-builder-75360",
        "inputs": {
            "statusCode": {
                "mode": "required",
                "type": "any"
            },
            "body": {
                "mode": "required",
                "type": "any"
            }
        },
        "outputs": {
            "r": {
                "type": "object"
            }
        },
        "customViewCode": "{\"statusCode\":\"${statusCode}\",\"body\":\"${body}\"}",
        "fnCode": "outputs.r.next(compileObjectTemplate(\"%7B%22statusCode%22%3A%22%24%7BstatusCode%7D%22%2C%22body%22%3A%22%24%7Bbody%7D%22%7D\", inputs));"
    },
    "Parse": {
        "id": "Parse",
        "inputs": {
            "str": {
                "mode": "required",
                "type": "any"
            }
        },
        "outputs": {
            "obj": {
                "type": "any"
            },
            "e": {
                "type": "any"
            }
        },
        "fnCode": "const { str } = inputs;\nconst { obj, e } = outputs;\n        \n// magic here\ntry {\n    obj.next(JSON.parse(str));\n} catch (err) {\n    console.error(\"error parsing json\", err, str);\n    e.next({str, e});\n}"
    },
    "ParseInt": {
        "id": "ParseInt",
        "inputs": {
            "str": {
                "mode": "required",
                "type": "any"
            },
            "base": {
                "mode": "optional",
                "type": "any"
            }
        },
        "outputs": {
            "r": {
                "type": "any"
            },
            "e": {
                "type": "any"
            }
        },
        "fnCode": "const { str, base } = inputs;\nconst { r, e } = outputs;\n        \n// magic here\nconst int = parseInt(str, base || 10);\nif (isNaN(int)) {\n    e.next(str);\n} else {\n    r.next(int);\n}  "
    },
    "Pick": {
        "id": "Pick",
        "inputs": {
            "obj": {
                "mode": "required",
                "type": "any"
            },
            "key": {
                "mode": "required",
                "type": "any"
            }
        },
        "outputs": {
            "r": {
                "type": "any"
            },
            "e": {
                "type": "any"
            }
        },
        "customViewCode": "<% if (inputs.key) { %> Pick \"<%- inputs.key %>\" <% } else { %> Pick <% } %>",
        "completionOutputs": [
            "r",
            "e"
        ],
        "fnCode": "const { obj, key } = inputs;\nconst { r, e } = outputs;\n\n// magic here\n\nlet hadError = false;\n\nconst matches = {};\n\nconst normalized = key.replace(/\\[\"(([^\"])+)\"\\]/g, (match, p1, p2, offset) => {\n  const key = `__$$KEY$$__${offset}`;\n  matches[key] = p1;\n  return `.${key}`;\n});\n\n// outputs.log.next({matches, normalized});\n\nconst path = normalized.split(\".\");\nlet o = { ...obj };\nfor (let p of path) {\n  const key = matches[p] || p;\n  if (o && isDefined(o[key]) && o[key] !== null) {\n    o = o[key];\n  } else {\n    e.next(obj);\n    hadError = true;\n  }\n}\n\nif (!hadError) {\n  r.next(o);\n}\n"
    },
    "Publish": {
        "id": "Publish",
        "inputs": {
            "key": {
                "mode": "required",
                "type": "any"
            },
            "value": {
                "mode": "required",
                "type": "any"
            }
        },
        "outputs": {},
        "fnCode": "// magic here\n\nPubSub.publish(inputs.key, inputs.value);"
    },
    "Random": {
        "id": "Random",
        "inputs": {
            "trigger": {
                "mode": "required",
                "type": "any"
            }
        },
        "outputs": {
            "r": {
                "type": "any"
            }
        },
        "completionOutputs": [
            "r"
        ],
        "fnCode": "const { trigger } = inputs;\nconst { r } = outputs;\n      \nr.next(Math.random());\n      "
    },
    "RegexMatch": {
        "id": "RegexMatch",
        "inputs": {
            "str": {
                "mode": "required",
                "type": "any"
            },
            "pattern": {
                "mode": "required",
                "type": "any"
            }
        },
        "outputs": {
            "match": {
                "type": "any"
            },
            "noMatch": {
                "type": "any"
            }
        },
        "fnCode": "const { str, pattern } = inputs;\nconst { match, noMatch } = outputs;\n        \n// magic here\nconst regex = new RegExp(pattern);\nconst matches = str.match(regex);\n\nif (matches) {\n    match.next(matches);\n} else {\n    noMatch.next(str);\n}   "
    },
    "ReloadPage": {
        "id": "ReloadPage",
        "inputs": {
            "reload": {
                "mode": "required",
                "type": "any"
            }
        },
        "outputs": {},
        "fnCode": "const document = getDocument();\ndocument.location.reload();\n"
    },
    "RemoveAttr": {
        "id": "RemoveAttr",
        "inputs": {
            "obj": {
                "mode": "required",
                "type": "any"
            },
            "k": {
                "mode": "required",
                "type": "any"
            }
        },
        "outputs": {
            "r": {
                "type": "any"
            }
        },
        "completionOutputs": [
            "r"
        ],
        "fnCode": "const { obj, k } = inputs;\nconst { r } = outputs;\n        \n// magic here\nconst o = { ...obj };\ndelete o[k];\nr.next(o);        "
    },
    "Repeat": {
        "id": "Repeat",
        "inputs": {
            "val": {
                "mode": "required",
                "type": "any"
            },
            "count": {
                "mode": "required",
                "type": "any"
            }
        },
        "outputs": {
            "r": {
                "type": "any"
            }
        },
        "completionOutputs": [
            "r"
        ],
        "fnCode": "// magic here\nconst {val, count} = inputs;\nconst {r} = outputs;\n\nfor (let i = 0; i < count; i++) {\n    r.next(val);\n}\n"
    },
    "Replace": {
        "id": "Replace",
        "inputs": {
            "str": {
                "mode": "required",
                "type": "any"
            },
            "from": {
                "mode": "required",
                "type": "any"
            },
            "to": {
                "mode": "required",
                "type": "any"
            }
        },
        "outputs": {
            "r": {
                "type": "any"
            }
        },
        "completionOutputs": [
            "r"
        ],
        "fnCode": "const { str, from, to } = inputs;\nconst { r } = outputs;\n        \n// magic here\nr.next(str.replace(from, to));"
    },
    "Round": {
        "id": "Round",
        "inputs": {
            "n": {
                "mode": "required",
                "type": "any"
            }
        },
        "outputs": {
            "r": {
                "type": "any"
            }
        },
        "completionOutputs": [
            "r"
        ],
        "fnCode": "const { n } = inputs;\nconst { r } = outputs;\n      \n// magic here\nr.next(Math.round(n));\n      "
    },
    "RoundRobin3": {
        "id": "RoundRobin3",
        "inputs": {
            "item": {
                "mode": "required",
                "type": "any"
            }
        },
        "outputs": {
            "r1": {
                "type": "any"
            },
            "r2": {
                "type": "any"
            },
            "r3": {
                "type": "any"
            }
        },
        "completionOutputs": [
            "never"
        ],
        "reactiveInputs": [
            "item"
        ],
        "fnCode": "// magic here\nconst {state} = adv;\nconst {r1, r2, r3} = outputs;\nconst curr = state.get('curr') || 0;\n\nconst o = [r1, r2, r3][curr];\n\nconst nextCurr = (curr + 1) % 3;\n\nlog(nextCurr, curr);\no.next(inputs.item);\nstate.set('curr', nextCurr);"
    },
    "ScanValue": {
        "id": "ScanValue",
        "inputs": {
            "value": {
                "mode": "required",
                "type": "any"
            },
            "initial": {
                "mode": "required",
                "type": "any"
            },
            "onValue": {
                "mode": "required",
                "type": "node({\"prevValue\": \"any\", \"currValue\": \"any\"}|{\"newVal\": \"any\"})"
            }
        },
        "outputs": {
            "r": {
                "type": "any"
            }
        },
        "completionOutputs": [
            "none"
        ],
        "reactiveInputs": [
            "value"
        ],
        "fnCode": "const { state, insId, execute, onCleanup, onArg } = adv;\nconst {initial, value, onValue } = inputs;\nconst {r} = outputs;\n\nconst prevValue = state.get(\"prevValue\") || initial;\n  \nconst newVal = dynamicOutput();\nconst prevValueArg = dynamicNodeInput();\nconst currValue = dynamicNodeInput();\nconst clean = execute(\nonValue,\n{ prevValue: prevValueArg, currValue },\n{ newVal },\n`${insId}-scan`\n);\n\nlog({value, prevValue});\n\nconst s = newVal.subscribe((val) => {\n    state.set(\"prevValue\", val);\n    r.next(val);\n    s.unsubscribe();\n    clean();\n});\n\ncurrValue.subject.next(value);\nprevValueArg.subject.next(prevValue);\n\n"
    },
    "SetAttr": {
        "id": "SetAttr",
        "inputs": {
            "obj": {
                "mode": "required",
                "type": "any"
            },
            "k": {
                "mode": "required",
                "type": "any"
            },
            "v": {
                "mode": "required",
                "type": "any"
            }
        },
        "outputs": {
            "r": {
                "type": "any"
            }
        },
        "completionOutputs": [
            "r"
        ],
        "fnCode": "const { obj, k, v } = inputs;\nconst { r } = outputs;\n        \n// magic here\nr.next({ ...obj, [k]: v });"
    },
    "SetItem": {
        "id": "SetItem",
        "inputs": {
            "key": {
                "mode": "required",
                "type": "any"
            },
            "value": {
                "mode": "required",
                "type": "any"
            }
        },
        "outputs": {
            "ok": {
                "type": "any"
            }
        },
        "completionOutputs": [
            "ok"
        ],
        "fnCode": "// magic here\n\nconst {key, value} = inputs;\nmongoDb.collection('__KVStore').updateOne({id: key}, {$set: {value}}, {upsert: true})\n    .then(() => outputs.ok.next(value))\n    .catch((err) => adv.onError(err));"
    },
    "SetState": {
        "id": "SetState",
        "inputs": {
            "key": {
                "mode": "required",
                "type": "any"
            },
            "value": {
                "mode": "required",
                "type": "any"
            }
        },
        "outputs": {
            "r": {
                "type": "any"
            }
        },
        "fnCode": "const {state} = adv;\nconst {key, value} = inputs;\n\nstate.set(key, value);\noutputs.r.next(value);\n\n"
    },
    "SliceList": {
        "id": "SliceList",
        "inputs": {
            "list": {
                "mode": "required",
                "type": "any"
            },
            "begin": {
                "mode": "required",
                "type": "any"
            },
            "end": {
                "mode": "required",
                "type": "any"
            }
        },
        "outputs": {
            "r": {
                "type": "any"
            }
        },
        "completionOutputs": [
            "r"
        ],
        "fnCode": "// magic here\nconst { list, begin, end} = inputs;\noutputs.r.next(\n    list.slice(begin, end)\n);"
    },
    "Split": {
        "id": "Split",
        "inputs": {
            "str": {
                "mode": "required",
                "type": "any"
            },
            "by": {
                "mode": "required",
                "type": "any"
            }
        },
        "outputs": {
            "r": {
                "type": "any"
            }
        },
        "completionOutputs": [
            "r"
        ],
        "fnCode": "const { str, by } = inputs;\nconst { r } = outputs;\n        \n// magic here\nr.next(str.split(by));"
    },
    "SpreadList": {
        "id": "SpreadList",
        "inputs": {
            "list": {
                "mode": "required",
                "type": "any"
            }
        },
        "outputs": {
            "length": {
                "type": "any"
            },
            "idx": {
                "type": "any"
            },
            "val": {
                "type": "any"
            }
        },
        "fnCode": "// magic here\nconst { list } = inputs;\nconst { val, idx, length } = outputs;\nlength.next(list.length);\nlist.forEach((v, i) => {\n    val.next(v);\n    idx.next(i);\n});"
    },
    "SpreadList5": {
        "id": "SpreadList5",
        "inputs": {
            "list": {
                "mode": "required",
                "type": "any"
            }
        },
        "outputs": {
            "first": {
                "type": "any"
            },
            "second": {
                "type": "any"
            },
            "rest": {
                "type": "any"
            }
        },
        "fnCode": "const { list } = inputs;\nconst { first, second, rest } = outputs;\n      \nconst [f, s, r] = list;\n\nf && first.next(f);\ns && second.next(s);\n\nr.length && rest.next(r)\n      "
    },
    "SpreadListDelayed": {
        "id": "SpreadListDelayed",
        "inputs": {
            "list": {
                "mode": "required",
                "type": "any"
            }
        },
        "outputs": {
            "val": {
                "type": "any"
            },
            "idx": {
                "type": "any"
            },
            "length": {
                "type": "any"
            }
        },
        "fnCode": "// magic here\nconst { list } = inputs;\nconst { val, idx, length } = outputs;\nlength.next(list.length);\nlist.forEach((v, i) => {\n    setTimeout(() => {\n        val.next(v);\n        idx.next(i);\n    }, 100 * idx);\n});"
    },
    "StringAppend": {
        "id": "StringAppend",
        "inputs": {
            "str": {
                "mode": "required",
                "type": "any"
            },
            "strToAppend": {
                "mode": "required",
                "type": "any"
            }
        },
        "outputs": {
            "r": {
                "type": "any"
            }
        },
        "completionOutputs": [
            "r"
        ],
        "fnCode": "// magic here// magic here\noutputs.r.next(`${inputs.str}${inputs.strToAppend}`);"
    },
    "Stringify": {
        "id": "Stringify",
        "inputs": {
            "obj": {
                "mode": "required",
                "type": "any"
            }
        },
        "outputs": {
            "r": {
                "type": "any"
            }
        },
        "completionOutputs": [
            "r"
        ],
        "fnCode": "const { obj } = inputs;\nconst { r } = outputs;\n        \n// magic here\nr.next(JSON.stringify(obj));"
    },
    "StringIncludes": {
        "id": "StringIncludes",
        "inputs": {
            "str": {
                "mode": "required",
                "type": "any"
            },
            "strToFind": {
                "mode": "required",
                "type": "any"
            }
        },
        "outputs": {
            "r": {
                "type": "any"
            },
            "else": {
                "type": "any"
            }
        },
        "customViewCode": "",
        "fnCode": "const { str, strToFind } = inputs;\nconst { r } = outputs;\n        \n// magic here\nif (str.includes(strToFind)) {\n    r.next(str);\n}  else {\n    outputs['else'].next(str);\n}"
    },
    "Subscribe": {
        "id": "Subscribe",
        "inputs": {
            "key": {
                "mode": "required",
                "type": "any"
            }
        },
        "outputs": {
            "val": {
                "type": "any"
            }
        },
        "completionOutputs": [
            "never"
        ],
        "fnCode": "// magic here\nconst token = PubSub.subscribe(inputs.key, (_, data) => {\n    outputs.val.next(data);\n});\n\nadv.onCleanup(() => {\n    log('Unsubscribing!');\n    PubSub.unsubscribe(token);\n});"
    },
    "SubStr": {
        "id": "SubStr",
        "inputs": {
            "str": {
                "mode": "required",
                "type": "any"
            },
            "from": {
                "mode": "required",
                "type": "any"
            },
            "to": {
                "mode": "optional",
                "type": "any"
            }
        },
        "outputs": {
            "r": {
                "type": "any"
            }
        },
        "completionOutputs": [
            "r"
        ],
        "fnCode": "const { str, from, to } = inputs;\nconst { r } = outputs;\n        \n// magic here\nr.next(str.substring(from, to));    "
    },
    "Subtract": {
        "id": "Subtract",
        "inputs": {
            "n1": {
                "mode": "required",
                "type": "any"
            },
            "n2": {
                "mode": "required",
                "type": "any"
            }
        },
        "outputs": {
            "r": {
                "type": "any"
            }
        },
        "customViewCode": "<% if (inputs.n2) { %>\n-<%-inputs.n2%>\n<% } %>",
        "completionOutputs": [
            "r"
        ],
        "fnCode": "const { n1, n2 } = inputs;\nconst { r } = outputs;\n      \nr.next(n1 - n2);\n      "
    },
    "Switch": {
        "id": "Switch",
        "inputs": {
            "val": {
                "mode": "required",
                "type": "any"
            },
            "case1": {
                "mode": "required",
                "type": "any"
            },
            "case2": {
                "mode": "required-if-connected",
                "type": "any"
            },
            "case3": {
                "mode": "required-if-connected",
                "type": "any"
            },
            "case4": {
                "mode": "required-if-connected",
                "type": "any"
            },
            "case5": {
                "mode": "required-if-connected",
                "type": "any"
            },
            "transform": {
                "mode": "required-if-connected",
                "type": "any"
            }
        },
        "outputs": {
            "is1": {
                "type": "any"
            },
            "is2": {
                "type": "any"
            },
            "is3": {
                "type": "any"
            },
            "is4": {
                "type": "any"
            },
            "is5": {
                "type": "any"
            },
            "other": {
                "type": "any"
            }
        },
        "fnCode": "const { val, case1, case2, case3, case4, case5, transform } = inputs;\nconst { is1, is2, is3, is4, is5, other } = outputs;\n\nconst valueToRespond = isDefined(transform) ? transform : val;\n// magic here\nswitch (val) {\n    case case1:\n        is1.next(valueToRespond);\n        break;\n    case case2:\n        is2.next(valueToRespond);\n        break;\n    case case3:\n        is3.next(valueToRespond);\n        break;\n    case case4:\n        is4.next(valueToRespond);\n        break;\n    case case4:\n        is5.next(valueToRespond);\n        break;\n    default:\n        other.next(valueToRespond);\n        break;\n}"
    },
    "Throttle": {
        "id": "Throttle",
        "inputs": {
            "value": {
                "mode": "required",
                "type": "any"
            },
            "threshold": {
                "mode": "required",
                "type": "any"
            }
        },
        "outputs": {
            "result": {
                "type": "any"
            },
            "available": {
                "type": "any"
            }
        },
        "customViewCode": "<% if (inputs.threshold) { %> Throttle  <%- inputs.threshold %>ms <% } else { %> Throttle <% } %>",
        "completionOutputs": [
            "available"
        ],
        "reactiveInputs": [
            "value"
        ],
        "fnCode": "const { value, threshold } = inputs;\nconst { result, available } = outputs;\n\nif (!adv.state.get(\"locked\")) {\n  adv.state.set(\"locked\", true);\n  result.next(value);\n  const timer = setTimeout(() => {\n    available.next(true);\n  }, threshold)\n  adv.onCleanup(() => clearTimeout(timer));\n} else {\n  adv.onError(new Error(`Throttled. Try again later`));\n}"
    },
    "Transform": {
        "id": "Transform",
        "inputs": {
            "from": {
                "mode": "required",
                "type": "any"
            },
            "to": {
                "mode": "required",
                "type": "any"
            }
        },
        "outputs": {
            "r": {
                "type": "any"
            }
        },
        "customViewCode": "<% if (inputs.to) { %> to \"<%- inputs.to %>\" <% } %>",
        "completionOutputs": [
            "r"
        ],
        "fnCode": "const { to } = inputs;\nconst { r } = outputs;\n        \n// magic here\nr.next(to);"
    },
    "WebScraper": {
        "id": "WebScraper",
        "inputs": {
            "url": {
                "mode": "required",
                "type": "any"
            },
            "config": {
                "mode": "required",
                "type": "any"
            }
        },
        "outputs": {
            "result": {
                "type": "any"
            }
        },
        "completionOutputs": [
            "result"
        ],
        "fnCode": "// magic here\nconst {onError} = adv;\n\nscrapeIt(inputs.url, inputs.config).then(({ data, response }) => {\n    outputs.result.next(data)\n}, err => {\n    onError(err);\n})"
    }
}